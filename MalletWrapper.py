
import subprocess
import os
import re
import csv

class MalletError(Exception):
	pass

class Mallet(object):
	
	def __init__(self, mallet_dir, memory=1):
		'''
		Constructor
		mallet_dir : str : file path of Mallet-2.x.x directory, with trailing slash
		memory : int, float : maximum gigabytes of memory to allocate to Mallet
		'''
		self.memory = memory
		self.mallet_dir = mallet_dir
		self.set_memory()
		self.set_output_dir()

	def set_memory(self):
		'''
		Sets the memory limit by editing a line in a batch file
		Default from constructor is 1gb
		'''
		# reads
		with open(self.mallet_dir + 'bin/mallet.bat', 'r') as file :
		  filedata = file.read()
		# replaces memory line
		filedata = re.sub('set MALLET_MEMORY=.*', 'set MALLET_MEMORY=' + str(self.memory), filedata)
		# writes
		with open(self.mallet_dir + 'bin/mallet.bat', 'w') as file:
		  file.write(filedata)

	def set_output_dir(self):
		'''
		Creates (if not already present) an output folder in the Mallet directory
		Sets stdout file path
		'''
		if not os.path.isdir(self.mallet_dir + 'MalletWrapper'):
			os.mkdir(self.mallet_dir + 'MalletWrapper')
		self.output_dir = self.mallet_dir + 'MalletWrapper/'
		self.stdout = self.output_dir + 'stdout.txt'
		
	def call(self, command):
		'''
		Executes a command within the Mallet directory
		Redirects all output to a txt file
		'''
		result = subprocess.call(command, cwd=self.mallet_dir, stderr=subprocess.STDOUT, stdout=open(self.stdout, 'w'))

	def execute(self, command, args):
		'''
		Cannot determine success/failure of Mallet command execution from exit codes (0 or 1)
		Checks whether the file that was supposed to be generated by a command is actually generated
		If the file did not previously exist, checks if it exists after command execution
		Otherwise, checks whether the modified timestamp of the file has changed
		'''
		start = None
		for arg in args:
			# for train_topics, this will be either 'output-topic-keys' or 'output-doc-topics' (not 'topic-word-weights-file')
			# it should not matter which of the three are checked; if the command fails, neither should be generated
			if 'output' in arg: 
				if os.path.isfile(args[arg]):
					start = os.path.getmtime(args[arg])
				break
		self.call(command)
		stop = None
		if os.path.isfile(args[arg]):
			stop = os.path.getmtime(args[arg])
		if not stop or start == stop:
			raise MalletError('\n\n' + args[arg] + ' was not generated from the command:\n\n"' + ' '.join(command) + 
							  '"\n\nCheck ' + self.output_dir + 'stdout.txt for details.\n')

	def build_command(self, operation, kwargs):
		'''
		Converts the command arguments from dictionary to list format
		'''
		command = ['bin/mallet', operation]
		for key, value in kwargs.items():
			if isinstance(value, list):
				command.extend(['--' + key.replace('_', '-'), ' '.join(value)])
			else:
				command.extend(['--' + key.replace('_', '-'), value])
		return command

	def import_dir(self, **kwargs):
		'''
		Calls the import-dir Mallet command
		Overwrites some arguments
		'''
		kwargs['keep_sequence'] = True # topic modeling currently only supports feature sequences: use --keep-sequence option when importing data.
		kwargs['output'] = self.output_dir + 'import.mallet'
		command = self.build_command(operation='import-dir', kwargs=kwargs)
		self.execute(command, kwargs)


	def import_file(self, **kwargs):
		'''
		Calls the import-file Mallet command
		Overwrites some arguments
		'''
		kwargs['keep_sequence'] = True # topic modeling currently only supports feature sequences: use --keep-sequence option when importing data.
		kwargs['output'] = self.output_dir + 'import.mallet'
		command = self.build_command(operation='import-file', kwargs=kwargs)
		self.execute(command, kwargs)

	def train_topics(self, **kwargs):
		'''
		Calls the train-topics Mallet command
		Overwrites some arguments
		'''
		kwargs['input'] = self.output_dir + 'import.mallet'
		kwargs['topic-word-weights-file'] = self.output_dir + 'topic_word_weights.txt'
		kwargs['output-topic-keys'] = self.output_dir + 'topic_keys.txt' # these can also be derived from topic-word-weights-file
		kwargs['output-doc-topics'] = self.output_dir + 'doc_topics.txt'
		# sets the doc-topics-threshold to a very low number if not specified
		# output-doc-topics format changes when this parameter is not specified
		# see https://github.com/mimno/Mallet/issues/41
		if not kwargs.get('doc-topics-threshold', False):
			kwargs['doc-topics-threshold'] = 0.00001
		command = self.build_command(operation='train-topics', kwargs=kwargs)
		self.execute(command, kwargs)
		# parses the files generated by the command into python objects
		self.parse_topic_keys()
		self.parse_doc_topics()
		self.parse_word_weights()

	def parse_topic_keys(self):
		'''
		Parses the output-topic-keys txt file generated by train_topics into a python object
		{topic # (int): {dirichlet parameter: float, words: list}, ... }
		'''
		self.topic_keys = dict()
		with open(self.output_dir + 'topic_keys.txt', mode='r', encoding='utf8') as file:
			for line in file:
				data = re.split('\t| ', line.strip()) # cols 0, 1, and 2 are tab delimited, the rest are space delimited
				self.topic_keys[int(data[0])] = {'dirichlet': float(data[1]), 'words': self.process_words(data[2:])}
	
	def parse_doc_topics(self):
		'''
		Parses the output-doc-topics txt file generated by train_topics into a python object
		{document # (int): {document name: e.g. file path (str), topics: {topic # (int): weight (float), ... }}, ... }
		'''
		self.doc_topics = dict()
		with open(self.output_dir + 'doc_topics.txt', mode='r', encoding='utf8') as file:
			next(file)
			for line in file:
				data = line.strip().split('\t')
				self.doc_topics[int(data[0])] = {'name': data[1], 'topics': self.process_topics(data[2:])}

	def parse_word_weights(self):
		'''
		Parses the topic-word-weights txt file generated by train_topics into a python object
		{topic # (int): {word (str): weight (float)}, ... }
		'''
		self.word_weights = dict()
		with open(self.output_dir + 'topic_word_weights.txt', mode='r', encoding='utf8') as file:
			for line in file:
				data = line.strip().split('\t')
				try:
					self.word_weights[int(data[0])][data[1]] = float(data[2])
				except KeyError:
					self.word_weights[int(data[0])] = {data[1]: float(data[2])}

	@staticmethod
	def process_words(words):
		return [' '.join(x.split('_')) for x in words]

	@staticmethod
	def process_topics(topics):
		topic_weights = dict()
		for i in range(0, len(topics), 2):
			topic_weights[int(topics[i])] = float(topics[i+1])
		return topic_weights